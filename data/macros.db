{"name":"Set Actor Link","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/control/energy-stream-link-white.webp","scope":"global","command":"/**\n * Change the folderName to the items folder from which you want\n * to copy the contents onto your selected token actor.\n */\n\nmain()\nasync function main() {\n    const folderName = \"dummy folder\";\n    const actorLink = true;\n\n    const folderId = game.collections.get(\"Folder\").getName(folderName).id;\n    const actors = game.collections.get(\"Actor\").filter(function (actor) {\n        return actor.folder?.id == folderId;\n    });\n    console.log(\"Folder Contents: \", actors);\n\n    actors.forEach(async function (actor) {\n        const actordata = actor.system;\n        await actor.update({\"prototypeToken.actorLink\" : actorLink});\n        console.log(\"Actor Link\", actor.prototypeToken.actorLink);\n    });\n}","flags":{"core":{"sourceId":"Macro.sdrdamQi2JHH9KVW"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1679759839066,"modifiedTime":1679759839066,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"1tf8uv7yP3cUXa83"}
{"name":"Delete Folder Items","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/cancel.svg","scope":"global","command":"/**\n * 1. Select the target actors folder.\n * 2. Select the target items folder.\n */\nasync function getActors() {\n    const folders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Actor\" });\n    const buttons = {};\n    for (const button of folders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the target Actors folder`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const actors = folders.find(folder => folder.name == label).contents;\n                getItems(actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function getItems(actors) {\n\n    if (actors.length == 0) {\n        ui.notifications.error(\"Please select a folder with actors\");\n        return;\n    }\n    const itemFolders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Item\" });\n    const buttons = {};\n    for (const button of itemFolders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the folder with the Items to Copy/Update`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const items = itemFolders.find(folder => folder.name == label).contents;\n                main(items, actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function main(items, actors) {\n    actors.forEach(async function (actor) {\n        const olditems = [];\n        items.forEach(function (baditem) {\n            // if there is an item of this name and type, delete it\n            const existing = actor.items.filter(item => item.name == baditem.name);\n            while (existing[0]) {\n                const current = existing.pop();\n                if (current.type == baditem.type)\n                    olditems.push(current.id)\n            }\n        });\n        await actor.deleteEmbeddedDocuments('Item', olditems);\n        console.log(`Deleted ${olditems.length} items on ${actor.name}.`);\n    });\n    ui.notifications.info(`Deletions completed successfully.`);\n\n}\ngetActors();","flags":{"core":{"sourceId":"Macro.qjPsH3JjBiuZcvHc"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018112735,"modifiedTime":1679759839068,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"9bMfa1Kj26Yg1C6w"}
{"name":"Toggle SP/MP","type":"script","scope":"global","author":"cBKvJi6BDRNRZTAN","img":"icons/commodities/tech/lever.webp","command":"const selected = game.canvas.tokens.controlled[0];\nlet current = selected.document.bar2.attribute;\nlet next = \"secondaries.sp\";\nif (current == \"secondaries.sp\") next = \"secondaries.mp\";\nselected.document.update({\"bar2.attribute\":next});","ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"flags":{"core":{"sourceId":"Macro.hNr8GZ32zOGwINjS"}},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1671191273083,"modifiedTime":1679759839068,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"AmsaFiBnWSVrvlvf"}
{"name":"Defences","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/defensive/shield-barrier-glowing-triangle-blue-yellow.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"block\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.0QYG9oSRkwplZrTP"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018143327,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":500000,"_id":"BVuAvtYLmIiZulAL"}
{"name":"General Rolls","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/trades/gaming-gambling-dice-gray.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"skill,spell\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.BlRSey9EutlsU6PC"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018158079,"modifiedTime":1679759839062,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"Dhaz2YHq64G7MUcq"}
{"name":"Toggle SP/MP","type":"script","scope":"global","author":"cBKvJi6BDRNRZTAN","img":"icons/commodities/tech/lever.webp","command":"const selected = game.canvas.tokens.controlled[0];\nlet current = selected.document.bar2.attribute;\nlet next = \"secondaries.sp\";\nif (current == \"secondaries.sp\") next = \"secondaries.mp\";\nselected.document.update({\"bar2.attribute\":next});","ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"flags":{"core":{"sourceId":"Macro.hNr8GZ32zOGwINjS"}},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1671191273083,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":350000,"_id":"KKQic3khJJYkwPe3"}
{"name":"Stat Rolls","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/control/buff-flight-wings-runes-blue.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Trait\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.G2ElnfQCBoynPDxI"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018162406,"modifiedTime":1679759839065,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"KTSUM7VLgQj977fw"}
{"name":"Weapons","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/melee/weapons-crossed-swords-black-gray.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Weapon\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.xvmfs0YISfnYMA8V"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018104714,"modifiedTime":1679759839061,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"NuZ4ETPFL45tZgjV"}
{"name":"worldData","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * Generates simplistic and more or less accurate report on data needed for initial load on top of what an empty world load would require.\n *\n * This is based mostly on viewed scene, all actors, all items directory content, and chat log.\n *\n * View the active/default scene to get more accurate idea of initial load. The flexibility is provided as compromise for not analyzing all scenes.\n *\n * TODO:\n * - Scrub duplicate images. They're loaded only once.\n */\n\nconst strippedBaseURI = document.baseURI.replace(/[^/]+$/, '');\n\nconst kbSize = (size) => Math.floor(size / 100) / 10;\nconst mbSize = (size) => Math.floor(size / 10_000) / 100;\nconst typedSize = (size) => size > 500_000 ? [mbSize(size), 'MB'] : [kbSize(size), 'kB'];\n\nconst imgSize = async (path) => {\n\tif (!path) return 0;\n\n\treturn new Promise(\n\t\t(clen) => fetch(path, { method: 'HEAD', redirect: 'manual' })\n\t\t\t.catch(() => { clen(0); })\n\t\t\t.then((rs) => clen(parseInt(rs?.headers?.get('Content-Length') ?? '0', 10)))\n\t);\n}\n\nconst transferSize = (doc) => JSON.stringify(doc.toObject()).length;\n\n(async () => {\n\tconst actors = [];\n\tlet fattestActor = { name: null, id: null, transferSize: 0, imgSize: 0, tokenSize: 0, totalSize: 0 };\n\tconst actorArr = game.actors.filter(a => a.permission >= 3);\n\n\tui.notifications.info(`Analyzing ${actorArr.length} actors...`);\n\n\tconsole.log('... processing actors');\n\tfor (const actor of actorArr) {\n\t\tconst nada = {\n\t\t\tname: actor.name,\n\t\t\tid: actor.id,\n\t\t\ttransferSize: transferSize(actor),\n\t\t\timgSize: await imgSize(actor.img), // profile image\n\t\t\ttokenSize: await imgSize(actor.data.token?.img), // token image\n\t\t\tget totalSize() {\n\t\t\t\treturn this.transferSize + this.imgSize + this.tokenSize;\n\t\t\t},\n\t\t};\n\t\tactors.push(nada);\n\t\tif (nada.totalSize > fattestActor.totalSize) fattestActor = nada;\n\t}\n\n\tui.notifications.info('Analyzing scenes...');\n\tconsole.log('... processing scenes');\n\tconst scnV = game.scenes.viewed;\n\tconst scnA = game.scenes.active;\n\n\tasync function analyzeScene(scene) {\n\t\tif (!scene) return null;\n\t\tconsole.log('... processing scene:', scene.id);\n\t\tlet templateImages = 0, tileImages = 0, templateCount = 0, tileCount = 0, tokenImages = 0, tokenCount = 0, tokenData = 0;\n\t\tfor (const t of scene.templates) {\n\t\t\ttemplateImages += await imgSize(t.img);\n\t\t\ttemplateCount++;\n\t\t}\n\t\tfor (const t of scene.tiles) {\n\t\t\ttileImages += await imgSize(t.img);\n\t\t\ttileCount++;\n\t\t}\n\t\tfor (const t of scene.tokens) {\n\t\t\tif (!t.isLinked) { // count token images only if they're unlinked, otherwise they're part of actor data\n\t\t\t\ttokenImages += await imgSize(t.data.img);\n\t\t\t\ttokenData += transferSize(t);\n\t\t\t}\n\t\t\ttokenCount++;\n\t\t}\n\t\tconst sceneData = {\n\t\t\ttransferSize: transferSize(scene),\n\t\t\timgSize: await imgSize(scene.img),\n\t\t\ttemplateImages,\n\t\t\ttemplateCount,\n\t\t\ttileImages,\n\t\t\ttokenCount,\n\t\t\ttokenImages,\n\t\t\ttokenData,\n\t\t\tget totalSize() {\n\t\t\t\treturn this.transferSize + this.imgSize + this.templateImages + this.tileImages;\n\t\t\t},\n\t\t};\n\n\t\treturn sceneData;\n\t}\n\n\tconst sceneA = await analyzeScene(scnA);\n\tconst sceneV = scnA?.id === scnV?.id ? null : await analyzeScene(scnV);\n\n\t// Analyze items\n\n\tconst itemArr = game.items.filter(i => i.permission >= 3);\n\tui.notifications.info(`Analyzing items directory (${itemArr.length} items)...`);\n\tconsole.log('... processing items directory');\n\tconst items = [];\n\tfor (const item of itemArr) {\n\t\tconst nida = {\n\t\t\tname: item.name,\n\t\t\tid: item.id,\n\t\t\ttransferSize: transferSize(item),\n\t\t\timg: item.img,\n\t\t\timgSize: await imgSize(item.img),\n\t\t\tget totalSize() {\n\t\t\t\treturn this.transferSize + this.imgSize\n\t\t\t},\n\t\t};\n\t\titems.push(nida);\n\t}\n\n\t// Analyze log\n\n\tui.notifications.info(`Analyzing chat log (${game.messages.contents.length} messages)...`);\n\tconsole.log('... processing chat log');\n\n\tconst log = {\n\t\tcount: 0,\n\t\ttransferSize: 0,\n\t\timgSize: 0,\n\t\tget totalSize() {\n\t\t\treturn this.transferSize + this.imgSize\n\t\t},\n\t};\n\n\tfor (const cm of game.messages.contents) {\n\t\tlog.count++;\n\t\tlog.transferSize += transferSize(cm);\n\t}\n\n\t// Collate results\n\n\tconsole.log('... results!');\n\n\tconst col = () => $('<div>').addClass('flexcol');\n\tconst row = () => $('<div>').addClass('flexrow').css({ 'flex-wrap': 'nowrap', 'flex': '0' });\n\tconst label = (text) => $('<label>').text(text).css({ 'white-space': 'nowrap' });\n\tconst h2 = (text) => $('<h2>').text(text);\n\tconst h3 = (text) => $('<h3>').text(text).css({ margin: '0', 'margin-top': '0.3em', 'font-weight': 'bold' });\n\tconst sizeString = (size) => {\n\t\tconst [n, l] = typedSize(size);\n\t\treturn `${n} ${l}`;\n\t}\n\n\tconst darkBg = () => { return { 'background-color': 'rgba(0,0,0,0.05)' } };\n\tconst numberS = () => { return { flex: '0 5em', 'text-align': 'right' } };\n\tconst leftLabel = () => { return { flex: '1 12em' } };\n\tconst bolded = () => { return { 'font-weight': 'bold' } };\n\n\tconst html = col();\n\n\tconst actorTotalTransfer = actors.reduce((a, x) => a + x.transferSize, 0),\n\t\tactorTotalImgs = actors.reduce((a, x) => a + x.imgSize + x.tokenSize, 0);\n\tconst itemTotalTransfer = items.reduce((a, x) => a + x.transferSize, 0),\n\t\titemTotalImgs = items.reduce((a, x) => a + x.imgSize, 0);\n\tconsole.log('ACTORS:', actors.length, 'entities;', ...typedSize(actorTotalTransfer), 'data;', ...typedSize(actorTotalImgs), 'images');\n\n\tconst totalTransfer = actorTotalTransfer + (sceneA?.transferSize ?? 0) + (sceneV?.transferSize ?? 0) + itemTotalTransfer + log.totalSize;\n\tconst totalImages = actorTotalImgs + (sceneA?.imgSize ?? 0) + (sceneV?.imgSize ?? 0) + itemTotalImgs;\n\tconst totalData = totalTransfer + totalImages;\n\n\t/** SCENE */\n\n\tconst sceneRow = row();\n\thtml.append(sceneRow);\n\n\tfunction renderSceneData(scene, scnlabel) {\n\t\tsceneRow.append(col().append(\n\t\t\trow().append(h2(scnlabel)),\n\t\t\trow().css(darkBg()).append(label('').css(leftLabel()), label('Count').css(numberS()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t\t\trow().append(label('Base').css(leftLabel()), label('').css(numberS()), label(sizeString(scene.transferSize)).css(numberS()), label(sizeString(scene.imgSize)).css(numberS()), label(sizeString(scene.totalSize)).css(numberS()).css(bolded())),\n\t\t\trow().append(label('Templates').css(leftLabel()), label(scene.templateCount).css(numberS()), label('').css(numberS()), label(sizeString(scene.templateImages)).css(numberS()), label('').css(numberS())),\n\t\t\trow().append(label('Tiles').css(leftLabel()), label(scene.tileCount).css(numberS()), label('').css(numberS()), label(sizeString(scene.tileImages)).css(numberS()), label('').css(numberS())),\n\t\t\trow().append(label('Tokens').css(leftLabel()), label(scene.tokenCount).css(numberS()), label('').css(numberS()), label(sizeString(scene.tokenImages)).css(numberS()), label('').css(numberS())),\n\t\t\trow().append(label('Total').css(leftLabel()), label('').css(numberS()), label('').css(numberS()), label(sizeString(scene.imgSize + scene.templateImages + scene.tileImages + scene.tokenImages)).css(numberS()), label(sizeString(scene.templateImages + scene.tileImages + scene.tokenImages + scene.totalSize)).css(numberS()).css(bolded())),\n\t\t));\n\n\t\tconsole.log('SCENE:', ...typedSize(scene.totalSize), 'data;', ...typedSize(scene.imgSize), 'image');\n\t\tconsole.log('ITEMS:', items.length, 'entities;', ...typedSize(itemTotalTransfer), 'data;', ...typedSize(itemTotalImgs), 'images');\n\t\tconsole.log('Total:',\n\t\t\tactors.length + items.length, 'objects;',\n\t\t\t...typedSize(totalTransfer), 'data;',\n\t\t\t...typedSize(totalImages), 'images'\n\t\t);\n\t}\n\n\tif (sceneA) renderSceneData(sceneA, 'Active Scene');\n\tsceneRow.append(row().css({ width: '5px', flex: '0 0 5px', 'max-width': '5px' }));\n\tif (sceneV) renderSceneData(sceneV, 'Viewed Scene');\n\telse sceneRow.append(col());\n\n\t// Helper functions and data\n\n\tfunction sortBySSize(a, b) {\n\t\treturn b.totalSize - a.totalSize;\n\t}\n\tactors.sort(sortBySSize);\n\titems.sort(sortBySSize);\n\n\tfunction handleFatty(d, el) {\n\t\tconsole.log(`> [${d.id}] ${d.name}`,\n\t\t\t...typedSize(d.totalSize ?? 0), '---',\n\t\t\t...typedSize(d.transferSize ?? 0), 'data',\n\t\t\t...typedSize((d.imgSize ?? 0) + (d.tokenSize ?? 0)), 'image(s)');\n\n\t\tel.append(\n\t\t\trow().append(\n\t\t\t\tlabel(d.name).css(leftLabel()),\n\t\t\t\tlabel(sizeString(d.transferSize ?? 0)).css(numberS()),\n\t\t\t\tlabel(sizeString((d.imgSize ?? 0) + (d.tokenSize ?? 0))).css(numberS()),\n\t\t\t\tlabel(sizeString(d.totalSize ?? 0)).css(numberS()),\n\t\t\t),\n\t\t);\n\t}\n\n\t/** bla */\n\n\tconst itemsAndActors = row();\n\thtml.append(itemsAndActors);\n\n\t/** ACTORS */\n\n\tconst actorEl = col();\n\titemsAndActors.append(actorEl.append(\n\t\t// $('<hr>'),\n\t\trow().append(h2('Actors')),\n\t\trow().css(darkBg()).append(label().css(leftLabel()), label('Count').css(numberS()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t\trow().append(label('All actors').css(leftLabel()), label(actors.length).css(numberS()), label(sizeString(actorTotalTransfer)).css(numberS()), label(sizeString(actorTotalImgs)).css(numberS()), label(sizeString(actorTotalTransfer + actorTotalImgs)).css(numberS()).css(bolded())),\n\t\trow().append(h3('Fattest')),\n\t\trow().css(darkBg()).append(label('Actor').css(bolded()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t));\n\n\titemsAndActors.append(row().css({ width: '5px', flex: '0 0 5px', 'max-width': '5px' }));\n\n\tconsole.log('Fattest Actors');\n\tfor (const a of actors.slice(0, 5))\n\t\thandleFatty(a, actorEl);\n\n\t/** ITEMS */\n\n\tconst itemEl = col();\n\titemsAndActors.append(itemEl.append(\n\t\t// $('<hr>'),\n\t\trow().append(h2('Items')),\n\t\trow().css(darkBg()).append(label().css(leftLabel()), label('Count').css(numberS()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t\trow().append(label('All items').css(leftLabel()), label(items.length).css(numberS()), label(sizeString(itemTotalTransfer)).css(numberS()), label(sizeString(itemTotalImgs)).css(numberS()), label(sizeString(itemTotalImgs + itemTotalTransfer)).css(numberS()).css(bolded())),\n\t\trow().append(h3('Fattest')),\n\t\trow().css(darkBg()).append(label('Item').css(bolded()), label('Data').css(numberS()), label('Image').css(numberS()), label('Total').css(numberS())),\n\t));\n\n\tconsole.log('Fattest Items');\n\tfor (const i of items.slice(0, 5))\n\t\thandleFatty(i, itemEl);\n\n\t/** CHAT LOG */\n\n\tconst finalLine = row();\n\thtml.append(finalLine);\n\tfinalLine.append(col().append(\n\t\th2('Chat Log'),\n\t\trow().css(darkBg()).append(label('').css(leftLabel()), label('Count').css(numberS()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t\trow().append(label('Messages').css(leftLabel()), label(log.count).css(numberS()), label(sizeString(log.transferSize)).css(numberS()), label('?').css(numberS()), label(sizeString(log.totalSize)).css(numberS()).css(bolded())),\n\t));\n\n\t/** Total */\n\n\tfinalLine.append(row().css({ width: '5px', flex: '0 0 5px', 'max-width': '5px' }));\n\n\tfinalLine.append(col().append(\n\t\th2('Total'),\n\t\trow().css(darkBg()).append(label('').css(leftLabel()), label('Data').css(numberS()), label('Images').css(numberS()), label('Total').css(numberS())),\n\t\trow().append(\n\t\t\tlabel('').css(leftLabel()),\n\t\t\tlabel(sizeString(totalTransfer)).css(numberS()),\n\t\t\tlabel(sizeString(totalImages)).css(numberS()),\n\t\t\tlabel(sizeString(totalData)).css(numberS()).css(bolded())\n\t\t),\n\t));\n\n\t/** Done */\n\n\tconsole.log('... all done!');\n\n\tnew Dialog({\n\t\ttitle: 'World Data',\n\t\tcontent: $('<div>').append(html).html(),\n\t\tbuttons: {},\n\t}, {\n\t\twidth: 780,\n\t}).render(true);\n})();","folder":"9Uc9Di3VqsbAATRj","sort":200000,"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"flags":{},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.05","coreVersion":"10.291","createdTime":1676670450940,"modifiedTime":1676670504337,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"_id":"PPlvKrnoKzueYmH6"}
{"name":"Update Folder Items","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/upgrade.svg","scope":"global","command":"/**\n * 1. Select the target actors folder.\n * 2. Select the target items folder.\n */\nasync function getActors() {\n    const folders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Actor\" });\n    const buttons = {};\n    for (const button of folders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the target Actors folder`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const actors = folders.find(folder => folder.name == label).contents;\n                getItems(actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function getItems(actors) {\n\n    if (actors.length == 0) {\n        ui.notifications.error(\"Please select a folder with actors\");\n        return;\n    }\n    const itemFolders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Item\" });\n    const buttons = {};\n    for (const button of itemFolders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the folder with the Items to Copy/Update`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const items = itemFolders.find(folder => folder.name == label).contents;\n                main(items, actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function main(items, actors) {\n    actors.forEach(async function (actor) {\n        const newitems = [];\n        const olditems = [];\n        items.forEach(function (newitem) {\n            // if there is already an item of this name and type, delete it\n            const existing = actor.items.filter(item => item.name == newitem.name);\n            while (existing[0]) {\n                const current = existing.pop();\n                if (current.type == newitem.type) {\n                    olditems.push(current.id)\n                    // set the chartype to the type of the actor\n                    newitem.system.chartype = actor.type;\n                    // add the item to the array of those to be added to the actor\n                    newitems.push(newitem);\n                }\n            }\n        });\n        await actor.deleteEmbeddedDocuments('Item', olditems);\n        await actor.createEmbeddedDocuments('Item', newitems, { renderSheet: false });\n        console.log(`Updated ${olditems.length} items on ${actor.name}.`);\n    });\n    ui.notifications.info(`Updates completed successfully.`,);\n\n}\ngetActors();","flags":{"core":{"sourceId":"Macro.Our9Wz3cJalH0Wi7"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018168303,"modifiedTime":1679759839061,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"SxnULC3FZbDJlbDf"}
{"name":"Copy Folder Items","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/village.svg","scope":"global","command":"/**\n * 1. Select the target actors folder.\n * 2. Select the target items folder.\n */\nasync function getActors() {\n    const folders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Actor\" });\n    const buttons = {};\n    for (const button of folders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the target Actors folder`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const actors = folders.find(folder => folder.name == label).contents;\n                getItems(actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function getItems(actors) {\n\n    if (actors.length == 0) {\n        ui.notifications.error(\"Please select a folder with actors\");\n        return;\n    }\n    const itemFolders = game.collections.get(\"Folder\").filter(c => { return c.type == \"Item\" });\n    const buttons = {};\n    for (const button of itemFolders) {\n        buttons[button.name] = {\n            label: button.name,\n            callback: () => {\n                applyChanges = true;\n                label = button.name\n            }\n        }\n    }\n    let applyChanges = false;\n    new Dialog({\n        title: `Select the folder with the Items to Copy/Update`,\n        buttons: buttons,\n        close: async html => {\n            if (applyChanges) {\n                const items = itemFolders.find(folder => folder.name == label).contents;\n                main(items, actors);\n            }\n        }\n    },\n        {\n            classes: [\"mydialog\"],\n            width: 175,\n            top: 0,\n            left: 0\n        }).render(true);\n}\n\nasync function main(items, actors) {\n    actors.forEach(async function (actor) {\n        const newitems = [];\n        const olditems = [];\n        items.forEach(function (newitem) {\n            // set the chartype to the type of the actor\n            newitem.system.chartype = actor.type;\n            // add the item to the array of those to be added to the actor\n            newitems.push(newitem);\n            const existing = actor.items.filter(item => item.name == newitem.name);\n            while (existing[0]) {\n                const current = existing.pop();\n                // if there is already an item of this name and type, delete it\n                if (current.type == newitem.type)\n                    olditems.push(current.id)\n            }\n        });\n        await actor.deleteEmbeddedDocuments('Item', olditems);\n        await actor.createEmbeddedDocuments('Item', newitems, { renderSheet: false });\n        console.log(`Copied ${newitems.length} items to ${actor.name}.`);\n        console.log(`Deleted ${olditems.length} items from ${actor.name}.`);\n    });\n    ui.notifications.info(`Copies and Updates completed successfully.`,);\n\n}\ngetActors();","flags":{"core":{"sourceId":"Macro.AdaSmSrw5j4UQfir"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018108349,"modifiedTime":1679759839067,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"VWePNTqlhDsoQWQI"}
{"name":"Stat Rolls","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/control/buff-flight-wings-runes-blue.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Trait\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.G2ElnfQCBoynPDxI"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018162406,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":700000,"_id":"hw4lHvNFReStlkXX"}
{"name":"General Rolls","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/trades/gaming-gambling-dice-gray.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"skill,spell\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.BlRSey9EutlsU6PC"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018158079,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":200000,"_id":"jRF7i9lUaSpWSL5L"}
{"name":"Toggle Folder Effects","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/commodities/tech/levers-colored.webp","scope":"global","command":"/**\n * This will bring up a dialog containing the names of all the conditions in \n * the specified items folder. They must all be modifiers that may be toggled \n * and you use that dialog to toggle the effect on selected tokens. This macro \n * will copy the condition to the token before toggling it so you will always \n * apply the most recent version of the condition.\n */\n\n const folderName = \"conditions\";\n\n /**\n  * @folderName is the case-sensitive name of the folder containing your conditions\n  */\n async function toggleFolderConditions(folderName) {\n   const folder = game.collections.get(\"Folder\").getName(folderName);\n   if (folder == undefined) {\n     ui.notifications.error(`The folder <b>${folderName}</b> was not found.`);\n     return;\n   }\n \n   const items = folder.contents;\n \n   const buttons = {};\n   for (const button of items) {\n     buttons[button.name] = {\n       label: button.name,\n       buttonData: button,\n       callback: () => {\n         (label = button.name), (icon = button.img), d.render(true);\n       },\n     };\n   }\n\n   let d = new Dialog(\n     {\n       title: `Toggle Status Effect`,\n       buttons: buttons,\n       close: async (html) => {\n         if (icon) {\n \n           const tokens = canvas.tokens.controlled;\n           if (tokens.length == 0) {\n             ui.notifications.error(\"Please select at least one token first\");\n             return;\n           }\n           for (const token of tokens) {\n             await token.toggleEffect({\n               icon: icon,\n               id: label,\n               label: label,\n             });\n             const actor = token.actor;\n             const olditems = [];\n             const itemdata = buttons[label].buttonData;\n             // set the chartype to the type of the actor\n             itemdata.system.chartype = actor.type;\n             // if there is already an item of this name and type, delete it\n             const existing = actor.items.filter((item) => item.name == itemdata.name);\n             while (existing[0]) {\n               const current = existing.pop();\n               if (current.type == itemdata.type) olditems.push(current.id);\n             }\n             await actor.deleteEmbeddedDocuments(\"Item\", olditems);\n \n             const inEffect = actor.effects.find((i) => i.label == label) != undefined;\n             if (inEffect) {\n                await actor.createEmbeddedDocuments(\"Item\", [itemdata], { renderSheet: false, });\n                const newitem = actor.items.filter((item) => item.name == itemdata.name)[0];\n                await actor.updateEmbeddedDocuments(\"Item\", [{ _id: newitem._id, \"system.inEffect\": true },]);\n             }\n           }\n           (label = \"\"), (icon = \"\");\n         }\n       },\n     },\n     {\n       width: 200,\n       classes: [\"mydialog\"],\n       top: 0,\n       left: 0,\n     }\n   );\n   d.render(true);\n }\n toggleFolderConditions(folderName);\n console.log(folderName);","flags":{"core":{"sourceId":"Macro.Bqnt3UoTNdgXLfe8"}},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018164390,"modifiedTime":1679759839063,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"jyL0Zn4VW7Oq2HnJ"}
{"name":"Compendium Savings","type":"script","scope":"global","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/dice-target.svg","command":"/**\n * Compendium Savings\n *\n * Displays how much data (in kB) certain documentsuse on world load currently\n *   and how much they'd use if they were in compendiums.\n *\n * Supported documents: actors, items, macros, journals, rolltables and scenes.\n *\n * By default some documents are skipped (can be configured below):\n * - player owned actors\n * - player visible macros and journals\n * - player navigable scenes (active or in navigation)\n *\n * Compatibility:\n * - Foundry v10\n */\n\nconst skipPlayerOwnedActors = true; // Skip player owned actors for putting into compendiums\nconst skipPlayerVisibleActors = true; // Skip actors that are visible to players\nconst skipPlayerUsableMacros = true; // Skip macros usable by players\nconst skipPlayerNavigableScenes = true; // Skip scenes that player can navigate to\n\nconst savingsType = 'both'; // 'both', 'percentage', or 'size'\n\n// Permission level at which something is considered player usable/visible (possibly swap this to OBSERVER)\nconst playerUseLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED;\n\nconst isPlayerVisible = (doc) => {\n\tif (doc.ownership.default >= playerUseLevel) return true;\n\treturn Object.entries(doc.ownership).some(([uid, level]) => !game.users.get(uid)?.isGM && level >= playerUseLevel);\n}\n\nconst countTrueSize = (arr) => arr\n\t.reduce((t, doc) => t + JSON.stringify(doc.toObject()).length, 0);\n\nconst countIndexSize = (arr, { documentName } = {}) => arr.reduce((t, doc) => {\n\tconst { _id, name } = doc.toObject();\n\tconst indexData = { _id, name };\n\tswitch (documentName) {\n\t\tcase 'Scene': {\n\t\t\tconst { thumb } = doc.toObject();\n\t\t\tObject.assign(indexData, { thumb });\n\t\t\tbreak;\n\t\t}\n\t\tcase 'JournalEntry':\n\t\t\t// Nothing needed here\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tconst { sort, type, img } = doc.toObject();\n\t\t\tObject.assign(indexData, { sort, type, img });\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (indexData._type === undefined) delete indexData._type; // Macros/RollTables don't have this\n\treturn t + JSON.stringify(indexData).length;\n}, 0);\n\n/**\n * @param {WorldCollection} list\n */\nconst makeCategory = (list, { skipPlayerOwned, skipPlayerVisible, skipPlayerNavigable } = {}) => {\n\tconst trueList = list.filter(d => {\n\t\tif (skipPlayerOwned && d.hasPlayerOwner) return false;\n\t\tif (skipPlayerVisible && isPlayerVisible(d)) return false;\n\t\tif (skipPlayerNavigable && (d.navigation && d.ownership.default > 0 || d.active)) return false;\n\t\treturn true;\n\t});\n\tconst count = Array.from(trueList).length;\n\tconst { documentName } = list;\n\treturn {\n\t\tcount,\n\t\tomitted: Array.from(list).length - count,\n\t\tunpacked: countTrueSize(trueList, { documentName }) / 1_000,\n\t\tpacked: countIndexSize(trueList, { documentName }) / 1_000,\n\t\tget ratio() {\n\t\t\treturn this.packed / this.unpacked;\n\t\t},\n\t\tget savings() {\n\t\t\tconst getPercentage = () => (1 - this.ratio) * 100;\n\t\t\tconst getSize = () => this.unpacked - this.packed;\n\t\t\tconst rd = Math.roundDecimals;\n\t\t\tswitch (savingsType[0]) {\n\t\t\t\tcase 'p':\n\t\t\t\t\treturn `${rd(getPercentage(), 1)}%`;\n\t\t\t\tcase 's':\n\t\t\t\t\treturn `${rd(getSize(), 1)} kB`;\n\t\t\t\tdefault:\n\t\t\t\t\treturn `${rd(getSize(), 1)} kB (${rd(getPercentage(), 1)}%)`;\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst templateData = {\n\titems: makeCategory(game.items),\n\tactors: makeCategory(game.actors, { skipPlayerOwned: skipPlayerOwnedActors, skipPlayerVisible: skipPlayerVisibleActors }),\n\ttables: makeCategory(game.tables),\n\tmacros: makeCategory(game.macros, { skipPlayerVisible: skipPlayerUsableMacros }),\n\tjournals: makeCategory(game.journal, { skipPlayerVisible: skipPlayerUsableMacros }),\n\tscenes: makeCategory(game.scenes, { skipPlayerNavigable: skipPlayerNavigableScenes }),\n};\n\nconst template = `\n<div style=\"display:grid;grid-template-columns:repeat(6, min-content);column-gap:0.5rem;row-gap:0.2rem;white-space:nowrap;\">\n<h3>Category</h3><h3>Count</h3><h3>Omitted</h3><h3>Unpacked</h3><h3>Packed</h3><h3>Savings</h3>\n<label>Actors</label><span style='justify-self:right;'>{{actors.count}}</span><span style='justify-self:right;'>{{actors.omitted}}</span><span style='justify-self:right;'>{{numberFormat actors.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat actors.packed decimals=2}} kB</span><span style='justify-self:right;'>{{actors.savings}}</span>\n<label>Items</label><span style='justify-self:right;'>{{items.count}}</span><span style='justify-self:right;'>{{items.omitted}}</span><span style='justify-self:right;'>{{numberFormat items.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat items.packed decimals=2}} kB</span><span style='justify-self:right;'>{{items.savings}}</span>\n<label>Macros</label><span style='justify-self:right;'>{{macros.count}}</span><span style='justify-self:right;'>{{macros.omitted}}</span><span style='justify-self:right;'>{{numberFormat macros.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat macros.packed decimals=2}} kB</span><span style='justify-self:right;'>{{macros.savings}}</span>\n<label>Journals</label><span style='justify-self:right;'>{{journals.count}}</span><span style='justify-self:right;'>{{journals.omitted}}</span><span style='justify-self:right;'>{{numberFormat journals.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat journals.packed decimals=2}} kB</span><span style='justify-self:right;'>{{journals.savings}}</span>\n<label>RollTables</label><span style='justify-self:right;'>{{tables.count}}</span><span style='justify-self:right;'>{{tables.omitted}}</span><span style='justify-self:right;'>{{numberFormat tables.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat tables.packed decimals=2}} kB</span><span style='justify-self:right;'>{{tables.savings}}</span>\n<label>Scenes</label><span style='justify-self:right;'>{{scenes.count}}</span><span style='justify-self:right;'>{{scenes.omitted}}</span><span style='justify-self:right;'>{{numberFormat scenes.unpacked decimals=2}} kB</span><span style='justify-self:right;'>{{numberFormat scenes.packed decimals=2}} kB</span><span style='justify-self:right;'>{{scenes.savings}}</span>\n</div>\n<hr>\n`;\n\nDialog.prompt({\n\ttitle: 'Compendium Savings',\n\tcontent: Handlebars.compile(template)(templateData, { allowProtoMethodsByDefault: true, allowProtoPropertiesByDefault: true }),\n\trejectClose: false,\n\toptions: {\n\t\twidth: 'auto',\n\t\theight: 'auto',\n\t\tjQuery: false\n\t}\n});","folder":"9Uc9Di3VqsbAATRj","sort":100000,"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"flags":{},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.05","coreVersion":"10.291","createdTime":1676004657427,"modifiedTime":1676670503501,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"_id":"ke4cWG2wI4claoIe"}
{"name":"Maneuvers","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/melee/maneuver-sword-katana-yellow.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"dodge,parry\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.IAwcSDdGJLOfOPWV"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018110206,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":600000,"_id":"lVTl4PGN7BX397vy"}
{"name":"Defences","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/defensive/shield-barrier-glowing-triangle-blue-yellow.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"block\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.0QYG9oSRkwplZrTP"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018143327,"modifiedTime":1679759839063,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"mxWqQMhvMqfDc1br"}
{"name":"Toggle Folder Effects","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/commodities/tech/levers-colored.webp","scope":"global","command":"/**\n * This will bring up a dialog containing the names of all the conditions in \n * the specified items folder. They must all be modifiers that may be toggled \n * and you use that dialog to toggle the effect on selected tokens. This macro \n * will copy the condition to the token before toggling it so you will always \n * apply the most recent version of the condition.\n */\n\n const folderName = \"conditions\";\n\n /**\n  * @folderName is the case-sensitive name of the folder containing your conditions\n  */\n async function toggleFolderConditions(folderName) {\n   const folder = game.collections.get(\"Folder\").getName(folderName);\n   if (folder == undefined) {\n     ui.notifications.error(`The folder <b>${folderName}</b> was not found.`);\n     return;\n   }\n \n   const items = folder.contents;\n \n   const buttons = {};\n   for (const button of items) {\n     buttons[button.name] = {\n       label: button.name,\n       buttonData: button,\n       callback: () => {\n         (label = button.name), (icon = button.img), d.render(true);\n       },\n     };\n   }\n\n   let d = new Dialog(\n     {\n       title: `Toggle Status Effect`,\n       buttons: buttons,\n       close: async (html) => {\n         if (icon) {\n \n           const tokens = canvas.tokens.controlled;\n           if (tokens.length == 0) {\n             ui.notifications.error(\"Please select at least one token first\");\n             return;\n           }\n           for (const token of tokens) {\n             await token.toggleEffect({\n               icon: icon,\n               id: label,\n               label: label,\n             });\n             const actor = token.actor;\n             const olditems = [];\n             const itemdata = buttons[label].buttonData;\n             // set the chartype to the type of the actor\n             itemdata.system.chartype = actor.type;\n             // if there is already an item of this name and type, delete it\n             const existing = actor.items.filter((item) => item.name == itemdata.name);\n             while (existing[0]) {\n               const current = existing.pop();\n               if (current.type == itemdata.type) olditems.push(current.id);\n             }\n             await actor.deleteEmbeddedDocuments(\"Item\", olditems);\n \n             const inEffect = actor.effects.find((i) => i.label == label) != undefined;\n             if (inEffect) {\n                await actor.createEmbeddedDocuments(\"Item\", [itemdata], { renderSheet: false, });\n                const newitem = actor.items.filter((item) => item.name == itemdata.name)[0];\n                await actor.updateEmbeddedDocuments(\"Item\", [{ _id: newitem._id, \"system.inEffect\": true },]);\n             }\n           }\n           (label = \"\"), (icon = \"\");\n         }\n       },\n     },\n     {\n       width: 200,\n       classes: [\"mydialog\"],\n       top: 0,\n       left: 0,\n     }\n   );\n   d.render(true);\n }\n toggleFolderConditions(folderName);\n console.log(folderName);","flags":{"core":{"sourceId":"Macro.Bqnt3UoTNdgXLfe8"}},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018164390,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"folder":"awtRhCjlqAaXVhjY","sort":300000,"_id":"n0zPugauOtqQDtVX"}
{"name":"Maneuvers","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/melee/maneuver-sword-katana-yellow.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"dodge,parry\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.IAwcSDdGJLOfOPWV"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018110206,"modifiedTime":1679759839063,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"ozM3JymSnPbzdIlf"}
{"name":"Todo","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/trades/gaming-gambling-dice-gray.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.BlRSey9EutlsU6PC"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018158079,"modifiedTime":1679529792999,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":null,"sort":100000,"_id":"qZEXwMlN2TF71GBY"}
{"name":"Weapons","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/skills/melee/weapons-crossed-swords-black-gray.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Weapon\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.xvmfs0YISfnYMA8V"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018104714,"modifiedTime":1679759942496,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":325000,"_id":"qhs5kGR01kUSlHtr"}
{"name":"Unlock Compendia","type":"script","scope":"global","author":"cBKvJi6BDRNRZTAN","img":"icons/svg/door-locked-outline.svg","command":"const locked = game.packs.filter(p => p.locked);\n// Unlock\nfor (let p of locked) await p.configure({locked:false});\n// Migrate\n//try { await game.pf1.migrateWorld(); } catch (_) {}\n// Re-lock\n//for (let p of locked) await p.configure({locked:true});","ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"flags":{"core":{"sourceId":"Macro.95jHl3OLCImiNEl0"}},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1668458195889,"modifiedTime":1679759839062,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"s3u6Dpfqfbr3QA3w"}
{"name":"Features","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/life/heart-cross-blue.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Feature\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.RrvCVjPc8tqapm5b"}},"ownership":{"default":3,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018160423,"modifiedTime":1679759942497,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"awtRhCjlqAaXVhjY","sort":1100000,"_id":"tLnMPP8Rncugp81d"}
{"name":"Features","type":"script","author":"cBKvJi6BDRNRZTAN","img":"icons/magic/life/heart-cross-blue.webp","scope":"global","command":"/**\n * Each field is a comma-separated list of the things you want\n * to include in the result. It matches against the text you\n * enter, so a category of \"s\" will match skill, spell and rms.\n *\n * type: may be any of {Primary, Melee, Ranged, \n * Attack, Rollable, Defence}\n *\n * category: applies only to:\n * Rollable: {check, skill, spell, technique, rms} and\n * Defence: {dodge, parry, block}\n * and may be used without specifying the type.\n *\n * group: is a user-defined field for use in filtering\n * this result.\n *\n * Target: Any case-sensitive portion of the item name.\n*/\n\nlet data = {\nposition: {\n  width: 300, \n  top: 100, \n  left: 100\n},\ntype: \"Feature\",\ncategory: \"\",\ngroup: \"\",\ntarget: \"\",\n};\n\nif (canvas.tokens.controlled.length != 1)\n    return ui.notifications.error(\"Please select a single token first\");\n\ncanvas.tokens.controlled[0].actor.rollables(data);","flags":{"core":{"sourceId":"Macro.RrvCVjPc8tqapm5b"}},"ownership":{"default":0,"cBKvJi6BDRNRZTAN":3},"_stats":{"systemId":"reclaim-the-wild","systemVersion":"2.06","coreVersion":"10.291","createdTime":1666018160423,"modifiedTime":1679759839069,"lastModifiedBy":"cBKvJi6BDRNRZTAN"},"folder":"OOxojO5yaT1dTp3p","sort":0,"_id":"w5ygbewS7xz99zhO"}
